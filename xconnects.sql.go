// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: xconnects.sql

package godevmandb

import (
	"context"
	"database/sql"

	"github.com/jackc/pgtype"
)

const CountXconnects = `-- name: CountXconnects :one
SELECT COUNT(*)
FROM xconnects
`

func (q *Queries) CountXconnects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountXconnects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateXconnect = `-- name: CreateXconnect :one
INSERT INTO xconnects (
        dev_id,
        peer_dev_id,
        if_id,
        vc_idx,
        vc_id,
        peer_ip,
        peer_ifalias,
        xname,
        descr,
        op_stat,
        op_stat_in,
        op_stat_out
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    )
RETURNING xc_id, dev_id, peer_dev_id, if_id, vc_idx, vc_id, peer_ip, peer_ifalias, xname, descr, op_stat, op_stat_in, op_stat_out, updated_on, created_on
`

type CreateXconnectParams struct {
	DevID       int64          `json:"dev_id"`
	PeerDevID   sql.NullInt64  `json:"peer_dev_id"`
	IfID        sql.NullInt64  `json:"if_id"`
	VcIdx       int64          `json:"vc_idx"`
	VcID        int64          `json:"vc_id"`
	PeerIp      pgtype.Inet    `json:"peer_ip"`
	PeerIfalias sql.NullString `json:"peer_ifalias"`
	Xname       sql.NullString `json:"xname"`
	Descr       sql.NullString `json:"descr"`
	OpStat      sql.NullString `json:"op_stat"`
	OpStatIn    sql.NullString `json:"op_stat_in"`
	OpStatOut   sql.NullString `json:"op_stat_out"`
}

func (q *Queries) CreateXconnect(ctx context.Context, arg CreateXconnectParams) (Xconnect, error) {
	row := q.db.QueryRow(ctx, CreateXconnect,
		arg.DevID,
		arg.PeerDevID,
		arg.IfID,
		arg.VcIdx,
		arg.VcID,
		arg.PeerIp,
		arg.PeerIfalias,
		arg.Xname,
		arg.Descr,
		arg.OpStat,
		arg.OpStatIn,
		arg.OpStatOut,
	)
	var i Xconnect
	err := row.Scan(
		&i.XcID,
		&i.DevID,
		&i.PeerDevID,
		&i.IfID,
		&i.VcIdx,
		&i.VcID,
		&i.PeerIp,
		&i.PeerIfalias,
		&i.Xname,
		&i.Descr,
		&i.OpStat,
		&i.OpStatIn,
		&i.OpStatOut,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteXconnect = `-- name: DeleteXconnect :exec
DELETE FROM xconnects
WHERE xc_id = $1
`

func (q *Queries) DeleteXconnect(ctx context.Context, xcID int64) error {
	_, err := q.db.Exec(ctx, DeleteXconnect, xcID)
	return err
}

const GetXconnect = `-- name: GetXconnect :one
SELECT xc_id, dev_id, peer_dev_id, if_id, vc_idx, vc_id, peer_ip, peer_ifalias, xname, descr, op_stat, op_stat_in, op_stat_out, updated_on, created_on
FROM xconnects
WHERE xc_id = $1
`

func (q *Queries) GetXconnect(ctx context.Context, xcID int64) (Xconnect, error) {
	row := q.db.QueryRow(ctx, GetXconnect, xcID)
	var i Xconnect
	err := row.Scan(
		&i.XcID,
		&i.DevID,
		&i.PeerDevID,
		&i.IfID,
		&i.VcIdx,
		&i.VcID,
		&i.PeerIp,
		&i.PeerIfalias,
		&i.Xname,
		&i.Descr,
		&i.OpStat,
		&i.OpStatIn,
		&i.OpStatOut,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetXconnectDevice = `-- name: GetXconnectDevice :one
SELECT t2.dev_id, t2.site_id, t2.dom_id, t2.snmp_main_id, t2.snmp_ro_id, t2.parent, t2.sys_id, t2.ip4_addr, t2.ip6_addr, t2.host_name, t2.sys_name, t2.sys_location, t2.sys_contact, t2.sw_version, t2.ext_model, t2.installed, t2.monitor, t2.graph, t2.backup, t2.source, t2.type_changed, t2.backup_failed, t2.validation_failed, t2.unresponsive, t2.notes, t2.updated_on, t2.created_on
FROM xconnects t1
    INNER JOIN devices t2 ON t2.dev_id = t1.dev_id
WHERE t1.xc_id = $1
`

// Foreign keys
func (q *Queries) GetXconnectDevice(ctx context.Context, xcID int64) (Device, error) {
	row := q.db.QueryRow(ctx, GetXconnectDevice, xcID)
	var i Device
	err := row.Scan(
		&i.DevID,
		&i.SiteID,
		&i.DomID,
		&i.SnmpMainID,
		&i.SnmpRoID,
		&i.Parent,
		&i.SysID,
		&i.Ip4Addr,
		&i.Ip6Addr,
		&i.HostName,
		&i.SysName,
		&i.SysLocation,
		&i.SysContact,
		&i.SwVersion,
		&i.ExtModel,
		&i.Installed,
		&i.Monitor,
		&i.Graph,
		&i.Backup,
		&i.Source,
		&i.TypeChanged,
		&i.BackupFailed,
		&i.ValidationFailed,
		&i.Unresponsive,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetXconnectInterface = `-- name: GetXconnectInterface :one
SELECT t2.if_id, t2.con_id, t2.parent, t2.otn_if_id, t2.dev_id, t2.ent_id, t2.ifindex, t2.descr, t2.alias, t2.oper, t2.adm, t2.speed, t2.minspeed, t2.type_enum, t2.mac, t2.monstatus, t2.monerrors, t2.monload, t2.updated_on, t2.created_on, t2.montraffic
FROM xconnects t1
    INNER JOIN interfaces t2 ON t2.if_id = t1.if_id
WHERE t1.xc_id = $1
`

// Foreign keys
func (q *Queries) GetXconnectInterface(ctx context.Context, xcID int64) (Interface, error) {
	row := q.db.QueryRow(ctx, GetXconnectInterface, xcID)
	var i Interface
	err := row.Scan(
		&i.IfID,
		&i.ConID,
		&i.Parent,
		&i.OtnIfID,
		&i.DevID,
		&i.EntID,
		&i.Ifindex,
		&i.Descr,
		&i.Alias,
		&i.Oper,
		&i.Adm,
		&i.Speed,
		&i.Minspeed,
		&i.TypeEnum,
		&i.Mac,
		&i.Monstatus,
		&i.Monerrors,
		&i.Monload,
		&i.UpdatedOn,
		&i.CreatedOn,
		&i.Montraffic,
	)
	return i, err
}

const GetXconnectPeerDevice = `-- name: GetXconnectPeerDevice :one
SELECT t2.dev_id, t2.site_id, t2.dom_id, t2.snmp_main_id, t2.snmp_ro_id, t2.parent, t2.sys_id, t2.ip4_addr, t2.ip6_addr, t2.host_name, t2.sys_name, t2.sys_location, t2.sys_contact, t2.sw_version, t2.ext_model, t2.installed, t2.monitor, t2.graph, t2.backup, t2.source, t2.type_changed, t2.backup_failed, t2.validation_failed, t2.unresponsive, t2.notes, t2.updated_on, t2.created_on
FROM xconnects t1
    INNER JOIN devices t2 ON t2.dev_id = t1.peer_dev_id
WHERE t1.xc_id = $1
`

// Foreign keys
func (q *Queries) GetXconnectPeerDevice(ctx context.Context, xcID int64) (Device, error) {
	row := q.db.QueryRow(ctx, GetXconnectPeerDevice, xcID)
	var i Device
	err := row.Scan(
		&i.DevID,
		&i.SiteID,
		&i.DomID,
		&i.SnmpMainID,
		&i.SnmpRoID,
		&i.Parent,
		&i.SysID,
		&i.Ip4Addr,
		&i.Ip6Addr,
		&i.HostName,
		&i.SysName,
		&i.SysLocation,
		&i.SysContact,
		&i.SwVersion,
		&i.ExtModel,
		&i.Installed,
		&i.Monitor,
		&i.Graph,
		&i.Backup,
		&i.Source,
		&i.TypeChanged,
		&i.BackupFailed,
		&i.ValidationFailed,
		&i.Unresponsive,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetXconnects = `-- name: GetXconnects :many
SELECT xc_id, dev_id, peer_dev_id, if_id, vc_idx, vc_id, peer_ip, peer_ifalias, xname, descr, op_stat, op_stat_in, op_stat_out, updated_on, created_on
FROM xconnects
ORDER BY dev_id, if_id
LIMIT $1
OFFSET $2
`

type GetXconnectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetXconnects(ctx context.Context, arg GetXconnectsParams) ([]Xconnect, error) {
	rows, err := q.db.Query(ctx, GetXconnects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Xconnect
	for rows.Next() {
		var i Xconnect
		if err := rows.Scan(
			&i.XcID,
			&i.DevID,
			&i.PeerDevID,
			&i.IfID,
			&i.VcIdx,
			&i.VcID,
			&i.PeerIp,
			&i.PeerIfalias,
			&i.Xname,
			&i.Descr,
			&i.OpStat,
			&i.OpStatIn,
			&i.OpStatOut,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateXconnect = `-- name: UpdateXconnect :one
UPDATE xconnects
SET dev_id = $2,
    peer_dev_id = $3,
    if_id = $4,
    vc_idx = $5,
    vc_id = $6,
    peer_ip = $7,
    peer_ifalias = $8,
    xname = $9,
    descr = $10,
    op_stat = $11,
    op_stat_in = $12,
    op_stat_out = $13
WHERE xc_id = $1
RETURNING xc_id, dev_id, peer_dev_id, if_id, vc_idx, vc_id, peer_ip, peer_ifalias, xname, descr, op_stat, op_stat_in, op_stat_out, updated_on, created_on
`

type UpdateXconnectParams struct {
	XcID        int64          `json:"xc_id"`
	DevID       int64          `json:"dev_id"`
	PeerDevID   sql.NullInt64  `json:"peer_dev_id"`
	IfID        sql.NullInt64  `json:"if_id"`
	VcIdx       int64          `json:"vc_idx"`
	VcID        int64          `json:"vc_id"`
	PeerIp      pgtype.Inet    `json:"peer_ip"`
	PeerIfalias sql.NullString `json:"peer_ifalias"`
	Xname       sql.NullString `json:"xname"`
	Descr       sql.NullString `json:"descr"`
	OpStat      sql.NullString `json:"op_stat"`
	OpStatIn    sql.NullString `json:"op_stat_in"`
	OpStatOut   sql.NullString `json:"op_stat_out"`
}

func (q *Queries) UpdateXconnect(ctx context.Context, arg UpdateXconnectParams) (Xconnect, error) {
	row := q.db.QueryRow(ctx, UpdateXconnect,
		arg.XcID,
		arg.DevID,
		arg.PeerDevID,
		arg.IfID,
		arg.VcIdx,
		arg.VcID,
		arg.PeerIp,
		arg.PeerIfalias,
		arg.Xname,
		arg.Descr,
		arg.OpStat,
		arg.OpStatIn,
		arg.OpStatOut,
	)
	var i Xconnect
	err := row.Scan(
		&i.XcID,
		&i.DevID,
		&i.PeerDevID,
		&i.IfID,
		&i.VcIdx,
		&i.VcID,
		&i.PeerIp,
		&i.PeerIfalias,
		&i.Xname,
		&i.Descr,
		&i.OpStat,
		&i.OpStatIn,
		&i.OpStatOut,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
