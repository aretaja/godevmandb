// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: archived_subinterfaces.sql

package godevmandb

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const CountArchivedSubInterfaces = `-- name: CountArchivedSubInterfaces :one
SELECT COUNT(*)
FROM archived_subinterfaces
`

func (q *Queries) CountArchivedSubInterfaces(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountArchivedSubInterfaces)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateArchivedSubInterface = `-- name: CreateArchivedSubInterface :one
INSERT INTO archived_subinterfaces (
    ifindex,
    descr,
    parent_descr,
    alias,
    type_enum,
    mac,
    hostname,
    host_ip4,
    host_ip6,
    notes
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING sifa_id, ifindex, descr, parent_descr, alias, type_enum, mac, hostname, host_ip4, host_ip6, notes, updated_on, created_on
`

type CreateArchivedSubInterfaceParams struct {
	Ifindex     sql.NullInt64  `json:"ifindex"`
	Descr       string         `json:"descr"`
	ParentDescr sql.NullString `json:"parent_descr"`
	Alias       sql.NullString `json:"alias"`
	TypeEnum    sql.NullString `json:"type_enum"`
	Mac         pgtype.Macaddr `json:"mac"`
	Hostname    string         `json:"hostname"`
	HostIp4     pgtype.Inet    `json:"host_ip4"`
	HostIp6     pgtype.Inet    `json:"host_ip6"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) CreateArchivedSubInterface(ctx context.Context, arg CreateArchivedSubInterfaceParams) (ArchivedSubinterface, error) {
	row := q.db.QueryRow(ctx, CreateArchivedSubInterface,
		arg.Ifindex,
		arg.Descr,
		arg.ParentDescr,
		arg.Alias,
		arg.TypeEnum,
		arg.Mac,
		arg.Hostname,
		arg.HostIp4,
		arg.HostIp6,
		arg.Notes,
	)
	var i ArchivedSubinterface
	err := row.Scan(
		&i.SifaID,
		&i.Ifindex,
		&i.Descr,
		&i.ParentDescr,
		&i.Alias,
		&i.TypeEnum,
		&i.Mac,
		&i.Hostname,
		&i.HostIp4,
		&i.HostIp6,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteArchivedSubInterface = `-- name: DeleteArchivedSubInterface :exec
DELETE FROM archived_subinterfaces
WHERE sifa_id = $1
`

func (q *Queries) DeleteArchivedSubInterface(ctx context.Context, sifaID int64) error {
	_, err := q.db.Exec(ctx, DeleteArchivedSubInterface, sifaID)
	return err
}

const GetArchivedSubInterface = `-- name: GetArchivedSubInterface :one
SELECT sifa_id, ifindex, descr, parent_descr, alias, type_enum, mac, hostname, host_ip4, host_ip6, notes, updated_on, created_on
FROM archived_subinterfaces
WHERE sifa_id = $1
`

func (q *Queries) GetArchivedSubInterface(ctx context.Context, sifaID int64) (ArchivedSubinterface, error) {
	row := q.db.QueryRow(ctx, GetArchivedSubInterface, sifaID)
	var i ArchivedSubinterface
	err := row.Scan(
		&i.SifaID,
		&i.Ifindex,
		&i.Descr,
		&i.ParentDescr,
		&i.Alias,
		&i.TypeEnum,
		&i.Mac,
		&i.Hostname,
		&i.HostIp4,
		&i.HostIp6,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetArchivedSubInterfaces = `-- name: GetArchivedSubInterfaces :many
SELECT sifa_id, ifindex, descr, parent_descr, alias, type_enum, mac, hostname, host_ip4, host_ip6, notes, updated_on, created_on
FROM archived_subinterfaces
WHERE (
    $1::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on >= $1
  )
  AND (
    $2::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on <= $2
  )
  AND (
    $3::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on >= $3
  )
  AND (
    $4::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on <= $4
  )
  AND (
    $5::text IS NULL
    OR CAST(ifindex AS text) LIKE $5
  )
  AND (
    $6::text = ''
    OR hostname LIKE $6
  )
  AND (
    $7::inet IS NULL
    OR host_ip4 <<= $7
  )
  AND (
    $8::inet IS NULL
    OR host_ip6 <<= $8
  )
  AND (
    $9::text = ''
    OR descr LIKE $9
  )
  AND (
    $10::text IS NULL
    OR alias LIKE $10
  )
  AND (
    $11::macaddr IS NULL
    OR mac = $11
  )
ORDER BY created_on
LIMIT NULLIF($13::int, 0) OFFSET NULLIF($12::int, 0)
`

type GetArchivedSubInterfacesParams struct {
	UpdatedGe time.Time      `json:"updated_ge"`
	UpdatedLe time.Time      `json:"updated_le"`
	CreatedGe time.Time      `json:"created_ge"`
	CreatedLe time.Time      `json:"created_le"`
	IfindexF  sql.NullString `json:"ifindex_f"`
	HostnameF string         `json:"hostname_f"`
	HostIp4F  pgtype.Inet    `json:"host_ip4_f"`
	HostIp6F  pgtype.Inet    `json:"host_ip6_f"`
	DescrF    string         `json:"descr_f"`
	AliasF    sql.NullString `json:"alias_f"`
	MacF      pgtype.Macaddr `json:"mac_f"`
	OffsetQ   int32          `json:"offset_q"`
	LimitQ    int32          `json:"limit_q"`
}

func (q *Queries) GetArchivedSubInterfaces(ctx context.Context, arg GetArchivedSubInterfacesParams) ([]ArchivedSubinterface, error) {
	rows, err := q.db.Query(ctx, GetArchivedSubInterfaces,
		arg.UpdatedGe,
		arg.UpdatedLe,
		arg.CreatedGe,
		arg.CreatedLe,
		arg.IfindexF,
		arg.HostnameF,
		arg.HostIp4F,
		arg.HostIp6F,
		arg.DescrF,
		arg.AliasF,
		arg.MacF,
		arg.OffsetQ,
		arg.LimitQ,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ArchivedSubinterface
	for rows.Next() {
		var i ArchivedSubinterface
		if err := rows.Scan(
			&i.SifaID,
			&i.Ifindex,
			&i.Descr,
			&i.ParentDescr,
			&i.Alias,
			&i.TypeEnum,
			&i.Mac,
			&i.Hostname,
			&i.HostIp4,
			&i.HostIp6,
			&i.Notes,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateArchivedSubInterface = `-- name: UpdateArchivedSubInterface :one
UPDATE archived_subinterfaces
SET ifindex = $2,
  descr = $3,
  parent_descr = $4,
  alias = $5,
  type_enum = $6,
  mac = $7,
  hostname = $8,
  host_ip4 = $9,
  host_ip6 = $10,
  notes = $11
WHERE sifa_id = $1
RETURNING sifa_id, ifindex, descr, parent_descr, alias, type_enum, mac, hostname, host_ip4, host_ip6, notes, updated_on, created_on
`

type UpdateArchivedSubInterfaceParams struct {
	SifaID      int64          `json:"sifa_id"`
	Ifindex     sql.NullInt64  `json:"ifindex"`
	Descr       string         `json:"descr"`
	ParentDescr sql.NullString `json:"parent_descr"`
	Alias       sql.NullString `json:"alias"`
	TypeEnum    sql.NullString `json:"type_enum"`
	Mac         pgtype.Macaddr `json:"mac"`
	Hostname    string         `json:"hostname"`
	HostIp4     pgtype.Inet    `json:"host_ip4"`
	HostIp6     pgtype.Inet    `json:"host_ip6"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) UpdateArchivedSubInterface(ctx context.Context, arg UpdateArchivedSubInterfaceParams) (ArchivedSubinterface, error) {
	row := q.db.QueryRow(ctx, UpdateArchivedSubInterface,
		arg.SifaID,
		arg.Ifindex,
		arg.Descr,
		arg.ParentDescr,
		arg.Alias,
		arg.TypeEnum,
		arg.Mac,
		arg.Hostname,
		arg.HostIp4,
		arg.HostIp6,
		arg.Notes,
	)
	var i ArchivedSubinterface
	err := row.Scan(
		&i.SifaID,
		&i.Ifindex,
		&i.Descr,
		&i.ParentDescr,
		&i.Alias,
		&i.TypeEnum,
		&i.Mac,
		&i.Hostname,
		&i.HostIp4,
		&i.HostIp6,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
