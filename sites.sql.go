// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: sites.sql

package godevmandb

import (
	"context"
	"time"
)

const CountSites = `-- name: CountSites :one
SELECT COUNT(*)
FROM sites
`

func (q *Queries) CountSites(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountSites)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSite = `-- name: CreateSite :one
INSERT INTO sites (
    country_id,
    uident,
    descr,
    latitude,
    longitude,
    area,
    addr,
    notes,
    ext_id,
    ext_name
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING site_id, country_id, uident, descr, latitude, longitude, area, addr, notes, ext_id, ext_name, updated_on, created_on
`

type CreateSiteParams struct {
	CountryID int64    `json:"country_id"`
	Uident    *string  `json:"uident"`
	Descr     string   `json:"descr"`
	Latitude  *float32 `json:"latitude"`
	Longitude *float32 `json:"longitude"`
	Area      *string  `json:"area"`
	Addr      *string  `json:"addr"`
	Notes     *string  `json:"notes"`
	ExtID     *int64   `json:"ext_id"`
	ExtName   *string  `json:"ext_name"`
}

func (q *Queries) CreateSite(ctx context.Context, arg CreateSiteParams) (Site, error) {
	row := q.db.QueryRow(ctx, CreateSite,
		arg.CountryID,
		arg.Uident,
		arg.Descr,
		arg.Latitude,
		arg.Longitude,
		arg.Area,
		arg.Addr,
		arg.Notes,
		arg.ExtID,
		arg.ExtName,
	)
	var i Site
	err := row.Scan(
		&i.SiteID,
		&i.CountryID,
		&i.Uident,
		&i.Descr,
		&i.Latitude,
		&i.Longitude,
		&i.Area,
		&i.Addr,
		&i.Notes,
		&i.ExtID,
		&i.ExtName,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteSite = `-- name: DeleteSite :exec
DELETE FROM sites
WHERE site_id = $1
`

func (q *Queries) DeleteSite(ctx context.Context, siteID int64) error {
	_, err := q.db.Exec(ctx, DeleteSite, siteID)
	return err
}

const GetSite = `-- name: GetSite :one
SELECT site_id, country_id, uident, descr, latitude, longitude, area, addr, notes, ext_id, ext_name, updated_on, created_on
FROM sites
WHERE site_id = $1
`

func (q *Queries) GetSite(ctx context.Context, siteID int64) (Site, error) {
	row := q.db.QueryRow(ctx, GetSite, siteID)
	var i Site
	err := row.Scan(
		&i.SiteID,
		&i.CountryID,
		&i.Uident,
		&i.Descr,
		&i.Latitude,
		&i.Longitude,
		&i.Area,
		&i.Addr,
		&i.Notes,
		&i.ExtID,
		&i.ExtName,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetSiteConnections = `-- name: GetSiteConnections :many
SELECT con_id, site_id, con_prov_id, con_type_id, con_cap_id, con_class_id, hint, notes, in_use, updated_on, created_on
FROM connections
WHERE site_id = $1
`

// Relations
func (q *Queries) GetSiteConnections(ctx context.Context, siteID int64) ([]Connection, error) {
	rows, err := q.db.Query(ctx, GetSiteConnections, siteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Connection
	for rows.Next() {
		var i Connection
		if err := rows.Scan(
			&i.ConID,
			&i.SiteID,
			&i.ConProvID,
			&i.ConTypeID,
			&i.ConCapID,
			&i.ConClassID,
			&i.Hint,
			&i.Notes,
			&i.InUse,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSiteCountry = `-- name: GetSiteCountry :one
SELECT t2.country_id, t2.code, t2.descr, t2.updated_on, t2.created_on
FROM sites t1
  INNER JOIN countries t2 ON t2.country_id = t1.country_id
WHERE t1.site_id = $1
`

// Foreign keys
func (q *Queries) GetSiteCountry(ctx context.Context, siteID int64) (Country, error) {
	row := q.db.QueryRow(ctx, GetSiteCountry, siteID)
	var i Country
	err := row.Scan(
		&i.CountryID,
		&i.Code,
		&i.Descr,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetSiteDevices = `-- name: GetSiteDevices :many
SELECT dev_id, site_id, dom_id, snmp_main_id, snmp_ro_id, parent, sys_id, ip4_addr, ip6_addr, host_name, sys_name, sys_location, sys_contact, sw_version, ext_model, installed, monitor, graph, backup, source, type_changed, backup_failed, validation_failed, unresponsive, notes, updated_on, created_on
FROM devices
WHERE site_id = $1
ORDER BY host_name
`

// Relations
func (q *Queries) GetSiteDevices(ctx context.Context, siteID *int64) ([]Device, error) {
	rows, err := q.db.Query(ctx, GetSiteDevices, siteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.DevID,
			&i.SiteID,
			&i.DomID,
			&i.SnmpMainID,
			&i.SnmpRoID,
			&i.Parent,
			&i.SysID,
			&i.Ip4Addr,
			&i.Ip6Addr,
			&i.HostName,
			&i.SysName,
			&i.SysLocation,
			&i.SysContact,
			&i.SwVersion,
			&i.ExtModel,
			&i.Installed,
			&i.Monitor,
			&i.Graph,
			&i.Backup,
			&i.Source,
			&i.TypeChanged,
			&i.BackupFailed,
			&i.ValidationFailed,
			&i.Unresponsive,
			&i.Notes,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSites = `-- name: GetSites :many
SELECT site_id, country_id, uident, descr, latitude, longitude, area, addr, notes, ext_id, ext_name, updated_on, created_on
FROM sites
WHERE (
    $1::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on >= $1
  )
  AND (
    $2::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on <= $2
  )
  AND (
    $3::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on >= $3
  )
  AND (
    $4::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on <= $4
  )
  AND (
    $5::text IS NULL
    OR ($5::text = 'isnull' AND uident IS NULL)
    OR ($5::text = 'isempty' AND uident = '')
    OR uident ILIKE $5
  )
  AND (
    $6::text = ''
    OR ($6 = 'isempty' AND descr = '')
    OR descr ILIKE $6
  )
  AND (
    $7::text IS NULL
    OR ($7::text = 'isnull' AND area IS NULL)
    OR ($7::text = 'isempty' AND area = '')
    OR area ILIKE $7
  )
  AND (
    $8::text IS NULL
    OR ($8::text = 'isnull' AND addr IS NULL)
    OR ($8::text = 'isempty' AND addr = '')
    OR addr ILIKE $8
  )
  AND (
    $9::text IS NULL
    OR ($9::text = 'isnull' AND notes IS NULL)
    OR ($9::text = 'isempty' AND notes = '')
    OR notes ILIKE $9
  )
  AND (
    $10::text IS NULL
    OR ($10::text = 'isnull' AND ext_name IS NULL)
    OR ($10::text = 'isempty' AND ext_name = '')
    OR ext_name ILIKE $10
  )
  AND (
    $11::text IS NULL
    OR ($11::text = 'isnull' AND ext_id IS NULL)
    OR ($11::text = 'isempty' AND CAST(ext_id AS text) = '')
    OR CAST(ext_id AS text) LIKE $11
  )
ORDER BY created_on
LIMIT NULLIF($13::int, 0) OFFSET NULLIF($12::int, 0)
`

type GetSitesParams struct {
	UpdatedGe time.Time `json:"updated_ge"`
	UpdatedLe time.Time `json:"updated_le"`
	CreatedGe time.Time `json:"created_ge"`
	CreatedLe time.Time `json:"created_le"`
	UidentF   *string   `json:"uident_f"`
	DescrF    string    `json:"descr_f"`
	AreaF     *string   `json:"area_f"`
	AddrF     *string   `json:"addr_f"`
	NotesF    *string   `json:"notes_f"`
	ExtNameF  *string   `json:"ext_name_f"`
	ExtIDF    *string   `json:"ext_id_f"`
	OffsetQ   int32     `json:"offset_q"`
	LimitQ    int32     `json:"limit_q"`
}

func (q *Queries) GetSites(ctx context.Context, arg GetSitesParams) ([]Site, error) {
	rows, err := q.db.Query(ctx, GetSites,
		arg.UpdatedGe,
		arg.UpdatedLe,
		arg.CreatedGe,
		arg.CreatedLe,
		arg.UidentF,
		arg.DescrF,
		arg.AreaF,
		arg.AddrF,
		arg.NotesF,
		arg.ExtNameF,
		arg.ExtIDF,
		arg.OffsetQ,
		arg.LimitQ,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Site
	for rows.Next() {
		var i Site
		if err := rows.Scan(
			&i.SiteID,
			&i.CountryID,
			&i.Uident,
			&i.Descr,
			&i.Latitude,
			&i.Longitude,
			&i.Area,
			&i.Addr,
			&i.Notes,
			&i.ExtID,
			&i.ExtName,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSite = `-- name: UpdateSite :one
UPDATE sites
SET country_id = $2,
  uident = $3,
  descr = $4,
  latitude = $5,
  longitude = $6,
  area = $7,
  addr = $8,
  notes = $9,
  ext_id = $10,
  ext_name = $11
WHERE site_id = $1
RETURNING site_id, country_id, uident, descr, latitude, longitude, area, addr, notes, ext_id, ext_name, updated_on, created_on
`

type UpdateSiteParams struct {
	SiteID    int64    `json:"site_id"`
	CountryID int64    `json:"country_id"`
	Uident    *string  `json:"uident"`
	Descr     string   `json:"descr"`
	Latitude  *float32 `json:"latitude"`
	Longitude *float32 `json:"longitude"`
	Area      *string  `json:"area"`
	Addr      *string  `json:"addr"`
	Notes     *string  `json:"notes"`
	ExtID     *int64   `json:"ext_id"`
	ExtName   *string  `json:"ext_name"`
}

func (q *Queries) UpdateSite(ctx context.Context, arg UpdateSiteParams) (Site, error) {
	row := q.db.QueryRow(ctx, UpdateSite,
		arg.SiteID,
		arg.CountryID,
		arg.Uident,
		arg.Descr,
		arg.Latitude,
		arg.Longitude,
		arg.Area,
		arg.Addr,
		arg.Notes,
		arg.ExtID,
		arg.ExtName,
	)
	var i Site
	err := row.Scan(
		&i.SiteID,
		&i.CountryID,
		&i.Uident,
		&i.Descr,
		&i.Latitude,
		&i.Longitude,
		&i.Area,
		&i.Addr,
		&i.Notes,
		&i.ExtID,
		&i.ExtName,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
