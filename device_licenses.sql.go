// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: device_licenses.sql

package godevmandb

import (
	"context"
	"database/sql"
)

const CountDeviceLicenses = `-- name: CountDeviceLicenses :one
SELECT COUNT(*)
FROM device_licenses
`

func (q *Queries) CountDeviceLicenses(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountDeviceLicenses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateDeviceLicense = `-- name: CreateDeviceLicense :one
INSERT INTO device_licenses (
    dev_id,
    product,
    descr,
    installed,
    unlocked,
    tot_inst,
    used,
    condition
  )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
`

type CreateDeviceLicenseParams struct {
	DevID     int64          `json:"dev_id"`
	Product   sql.NullString `json:"product"`
	Descr     sql.NullString `json:"descr"`
	Installed sql.NullInt32  `json:"installed"`
	Unlocked  sql.NullInt32  `json:"unlocked"`
	TotInst   sql.NullInt32  `json:"tot_inst"`
	Used      sql.NullInt32  `json:"used"`
	Condition sql.NullString `json:"condition"`
}

func (q *Queries) CreateDeviceLicense(ctx context.Context, arg CreateDeviceLicenseParams) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, CreateDeviceLicense,
		arg.DevID,
		arg.Product,
		arg.Descr,
		arg.Installed,
		arg.Unlocked,
		arg.TotInst,
		arg.Used,
		arg.Condition,
	)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteDeviceLicense = `-- name: DeleteDeviceLicense :exec
DELETE FROM device_licenses
WHERE lic_id = $1
`

func (q *Queries) DeleteDeviceLicense(ctx context.Context, licID int64) error {
	_, err := q.db.Exec(ctx, DeleteDeviceLicense, licID)
	return err
}

const GetDeviceLicense = `-- name: GetDeviceLicense :one
SELECT lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
FROM device_licenses
WHERE lic_id = $1
`

func (q *Queries) GetDeviceLicense(ctx context.Context, licID int64) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, GetDeviceLicense, licID)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetDeviceLicenseDevice = `-- name: GetDeviceLicenseDevice :one
SELECT t2.dev_id, t2.site_id, t2.dom_id, t2.snmp_main_id, t2.snmp_ro_id, t2.parent, t2.sys_id, t2.ip4_addr, t2.ip6_addr, t2.host_name, t2.sys_name, t2.sys_location, t2.sys_contact, t2.sw_version, t2.ext_model, t2.installed, t2.monitor, t2.graph, t2.backup, t2.source, t2.type_changed, t2.backup_failed, t2.validation_failed, t2.unresponsive, t2.notes, t2.updated_on, t2.created_on
FROM device_licenses t1
  INNER JOIN devices t2 ON t2.dev_id = t1.dev_id
WHERE t1.lic_id = $1
`

// Foreign keys
func (q *Queries) GetDeviceLicenseDevice(ctx context.Context, licID int64) (Device, error) {
	row := q.db.QueryRow(ctx, GetDeviceLicenseDevice, licID)
	var i Device
	err := row.Scan(
		&i.DevID,
		&i.SiteID,
		&i.DomID,
		&i.SnmpMainID,
		&i.SnmpRoID,
		&i.Parent,
		&i.SysID,
		&i.Ip4Addr,
		&i.Ip6Addr,
		&i.HostName,
		&i.SysName,
		&i.SysLocation,
		&i.SysContact,
		&i.SwVersion,
		&i.ExtModel,
		&i.Installed,
		&i.Monitor,
		&i.Graph,
		&i.Backup,
		&i.Source,
		&i.TypeChanged,
		&i.BackupFailed,
		&i.ValidationFailed,
		&i.Unresponsive,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetDeviceLicenses = `-- name: GetDeviceLicenses :many
SELECT lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
FROM device_licenses
ORDER BY dev_id, descr
LIMIT $1
OFFSET $2
`

type GetDeviceLicensesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetDeviceLicenses(ctx context.Context, arg GetDeviceLicensesParams) ([]DeviceLicense, error) {
	rows, err := q.db.Query(ctx, GetDeviceLicenses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceLicense
	for rows.Next() {
		var i DeviceLicense
		if err := rows.Scan(
			&i.LicID,
			&i.DevID,
			&i.Product,
			&i.Descr,
			&i.Installed,
			&i.Unlocked,
			&i.TotInst,
			&i.Used,
			&i.Condition,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateDeviceLicense = `-- name: UpdateDeviceLicense :one
UPDATE device_licenses
SET dev_id = $2,
  product = $3,
  descr = $4,
  installed = $5,
  unlocked = $6,
  tot_inst = $7,
  used = $8,
  condition = $9
WHERE lic_id = $1
RETURNING lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
`

type UpdateDeviceLicenseParams struct {
	LicID     int64          `json:"lic_id"`
	DevID     int64          `json:"dev_id"`
	Product   sql.NullString `json:"product"`
	Descr     sql.NullString `json:"descr"`
	Installed sql.NullInt32  `json:"installed"`
	Unlocked  sql.NullInt32  `json:"unlocked"`
	TotInst   sql.NullInt32  `json:"tot_inst"`
	Used      sql.NullInt32  `json:"used"`
	Condition sql.NullString `json:"condition"`
}

func (q *Queries) UpdateDeviceLicense(ctx context.Context, arg UpdateDeviceLicenseParams) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, UpdateDeviceLicense,
		arg.LicID,
		arg.DevID,
		arg.Product,
		arg.Descr,
		arg.Installed,
		arg.Unlocked,
		arg.TotInst,
		arg.Used,
		arg.Condition,
	)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
