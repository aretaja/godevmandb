// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: device_licenses.sql

package godevmandb

import (
	"context"
	"time"
)

const CountDeviceLicenses = `-- name: CountDeviceLicenses :one
SELECT COUNT(*)
FROM device_licenses
`

func (q *Queries) CountDeviceLicenses(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountDeviceLicenses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateDeviceLicense = `-- name: CreateDeviceLicense :one
INSERT INTO device_licenses (
    dev_id,
    product,
    descr,
    installed,
    unlocked,
    tot_inst,
    used,
    condition
  )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
`

type CreateDeviceLicenseParams struct {
	DevID     int64   `json:"dev_id"`
	Product   *string `json:"product"`
	Descr     *string `json:"descr"`
	Installed *int32  `json:"installed"`
	Unlocked  *int32  `json:"unlocked"`
	TotInst   *int32  `json:"tot_inst"`
	Used      *int32  `json:"used"`
	Condition *string `json:"condition"`
}

func (q *Queries) CreateDeviceLicense(ctx context.Context, arg CreateDeviceLicenseParams) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, CreateDeviceLicense,
		arg.DevID,
		arg.Product,
		arg.Descr,
		arg.Installed,
		arg.Unlocked,
		arg.TotInst,
		arg.Used,
		arg.Condition,
	)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteDeviceLicense = `-- name: DeleteDeviceLicense :exec
DELETE FROM device_licenses
WHERE lic_id = $1
`

func (q *Queries) DeleteDeviceLicense(ctx context.Context, licID int64) error {
	_, err := q.db.Exec(ctx, DeleteDeviceLicense, licID)
	return err
}

const GetDeviceLicense = `-- name: GetDeviceLicense :one
SELECT lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
FROM device_licenses
WHERE lic_id = $1
`

func (q *Queries) GetDeviceLicense(ctx context.Context, licID int64) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, GetDeviceLicense, licID)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetDeviceLicenseDevice = `-- name: GetDeviceLicenseDevice :one
SELECT t2.dev_id, t2.site_id, t2.dom_id, t2.snmp_main_id, t2.snmp_ro_id, t2.parent, t2.sys_id, t2.ip4_addr, t2.ip6_addr, t2.host_name, t2.sys_name, t2.sys_location, t2.sys_contact, t2.sw_version, t2.ext_model, t2.installed, t2.monitor, t2.graph, t2.backup, t2.source, t2.type_changed, t2.backup_failed, t2.validation_failed, t2.unresponsive, t2.notes, t2.updated_on, t2.created_on
FROM device_licenses t1
  INNER JOIN devices t2 ON t2.dev_id = t1.dev_id
WHERE t1.lic_id = $1
`

// Foreign keys
func (q *Queries) GetDeviceLicenseDevice(ctx context.Context, licID int64) (Device, error) {
	row := q.db.QueryRow(ctx, GetDeviceLicenseDevice, licID)
	var i Device
	err := row.Scan(
		&i.DevID,
		&i.SiteID,
		&i.DomID,
		&i.SnmpMainID,
		&i.SnmpRoID,
		&i.Parent,
		&i.SysID,
		&i.Ip4Addr,
		&i.Ip6Addr,
		&i.HostName,
		&i.SysName,
		&i.SysLocation,
		&i.SysContact,
		&i.SwVersion,
		&i.ExtModel,
		&i.Installed,
		&i.Monitor,
		&i.Graph,
		&i.Backup,
		&i.Source,
		&i.TypeChanged,
		&i.BackupFailed,
		&i.ValidationFailed,
		&i.Unresponsive,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetDeviceLicenses = `-- name: GetDeviceLicenses :many
SELECT lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
FROM device_licenses
WHERE (
    $1::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on >= $1
  )
  AND (
    $2::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on <= $2
  )
  AND (
    $3::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on >= $3
  )
  AND (
    $4::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on <= $4
  )
  AND (
    $3::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on >= $3
  )
  AND (
    $5::text IS NULL
    OR ($5::text = 'isnull' AND installed IS NULL)
    OR installed <= CAST($5 AS integer)
  )
  AND (
    $6::text IS NULL
    OR ($6::text = 'isnull' AND installed IS NULL)
    OR installed >= CAST($6 AS integer)
  )
  AND (
    $7::text IS NULL
    OR ($7::text = 'isnull' AND unlocked IS NULL)
    OR unlocked <= CAST($7 AS integer)
  )
  AND (
    $8::text IS NULL
    OR ($8::text = 'isnull' AND unlocked IS NULL)
    OR unlocked >= CAST($8 AS integer)
  )
  AND (
    $9::text IS NULL
    OR ($9::text = 'isnull' AND tot_inst IS NULL)
    OR tot_inst <= CAST($9 AS integer)
  )
  AND (
    $10::text IS NULL
    OR ($10::text = 'isnull' AND tot_inst IS NULL)
    OR tot_inst >= CAST($10 AS integer)
  )
  AND (
    $11::text IS NULL
    OR ($11::text = 'isnull' AND used IS NULL)
    OR used <= CAST($11 AS integer)
  )
  AND (
    $12::text IS NULL
    OR ($12::text = 'isnull' AND used IS NULL)
    OR used >= CAST($12 AS integer)
  )
  AND (
    $13::text IS NULL
    OR ($13::text = 'isnull' AND product IS NULL)
    OR ($13::text = 'isempty' AND product = '')
    OR product ILIKE $13
  )
  AND (
    $14::text IS NULL
    OR ($14::text = 'isnull' AND descr IS NULL)
    OR ($14::text = 'isempty' AND descr = '')
    OR descr ILIKE $14
  )
  AND (
    $15::text IS NULL
    OR ($15::text = 'isnull' AND condition IS NULL)
    OR ($15::text = 'isempty' AND condition = '')
    OR condition ILIKE $15
  )
ORDER BY created_on
LIMIT NULLIF($17::int, 0) OFFSET NULLIF($16::int, 0)
`

type GetDeviceLicensesParams struct {
	UpdatedGe   time.Time `json:"updated_ge"`
	UpdatedLe   time.Time `json:"updated_le"`
	CreatedGe   time.Time `json:"created_ge"`
	CreatedLe   time.Time `json:"created_le"`
	InstalledLe *string   `json:"installed_le"`
	InstalledGe *string   `json:"installed_ge"`
	UnlockedLe  *string   `json:"unlocked_le"`
	UnlockedGe  *string   `json:"unlocked_ge"`
	TotInstLe   *string   `json:"tot_inst_le"`
	TotInstGe   *string   `json:"tot_inst_ge"`
	UsedLe      *string   `json:"used_le"`
	UsedGe      *string   `json:"used_ge"`
	ProductF    *string   `json:"product_f"`
	DescrF      *string   `json:"descr_f"`
	ConditionF  *string   `json:"condition_f"`
	OffsetQ     int32     `json:"offset_q"`
	LimitQ      int32     `json:"limit_q"`
}

func (q *Queries) GetDeviceLicenses(ctx context.Context, arg GetDeviceLicensesParams) ([]DeviceLicense, error) {
	rows, err := q.db.Query(ctx, GetDeviceLicenses,
		arg.UpdatedGe,
		arg.UpdatedLe,
		arg.CreatedGe,
		arg.CreatedLe,
		arg.InstalledLe,
		arg.InstalledGe,
		arg.UnlockedLe,
		arg.UnlockedGe,
		arg.TotInstLe,
		arg.TotInstGe,
		arg.UsedLe,
		arg.UsedGe,
		arg.ProductF,
		arg.DescrF,
		arg.ConditionF,
		arg.OffsetQ,
		arg.LimitQ,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceLicense
	for rows.Next() {
		var i DeviceLicense
		if err := rows.Scan(
			&i.LicID,
			&i.DevID,
			&i.Product,
			&i.Descr,
			&i.Installed,
			&i.Unlocked,
			&i.TotInst,
			&i.Used,
			&i.Condition,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateDeviceLicense = `-- name: UpdateDeviceLicense :one
UPDATE device_licenses
SET dev_id = $2,
  product = $3,
  descr = $4,
  installed = $5,
  unlocked = $6,
  tot_inst = $7,
  used = $8,
  condition = $9
WHERE lic_id = $1
RETURNING lic_id, dev_id, product, descr, installed, unlocked, tot_inst, used, condition, updated_on, created_on
`

type UpdateDeviceLicenseParams struct {
	LicID     int64   `json:"lic_id"`
	DevID     int64   `json:"dev_id"`
	Product   *string `json:"product"`
	Descr     *string `json:"descr"`
	Installed *int32  `json:"installed"`
	Unlocked  *int32  `json:"unlocked"`
	TotInst   *int32  `json:"tot_inst"`
	Used      *int32  `json:"used"`
	Condition *string `json:"condition"`
}

func (q *Queries) UpdateDeviceLicense(ctx context.Context, arg UpdateDeviceLicenseParams) (DeviceLicense, error) {
	row := q.db.QueryRow(ctx, UpdateDeviceLicense,
		arg.LicID,
		arg.DevID,
		arg.Product,
		arg.Descr,
		arg.Installed,
		arg.Unlocked,
		arg.TotInst,
		arg.Used,
		arg.Condition,
	)
	var i DeviceLicense
	err := row.Scan(
		&i.LicID,
		&i.DevID,
		&i.Product,
		&i.Descr,
		&i.Installed,
		&i.Unlocked,
		&i.TotInst,
		&i.Used,
		&i.Condition,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
