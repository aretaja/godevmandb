// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: subinterfaces.sql

package godevmandb

import (
	"context"
	"time"

	"github.com/jackc/pgtype"
)

const CountSubinterfaces = `-- name: CountSubinterfaces :one
SELECT COUNT(*)
FROM subinterfaces
`

func (q *Queries) CountSubinterfaces(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountSubinterfaces)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSubinterface = `-- name: CreateSubinterface :one
INSERT INTO subinterfaces (
    if_id,
    ifindex,
    descr,
    alias,
    oper,
    adm,
    speed,
    type_enum,
    mac,
    notes
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING sif_id, if_id, ifindex, descr, alias, oper, adm, speed, type_enum, mac, notes, updated_on, created_on
`

type CreateSubinterfaceParams struct {
	IfID     *int64         `json:"if_id"`
	Ifindex  *int64         `json:"ifindex"`
	Descr    string         `json:"descr"`
	Alias    *string        `json:"alias"`
	Oper     *int16         `json:"oper"`
	Adm      *int16         `json:"adm"`
	Speed    *int64         `json:"speed"`
	TypeEnum *string        `json:"type_enum"`
	Mac      pgtype.Macaddr `json:"mac"`
	Notes    *string        `json:"notes"`
}

func (q *Queries) CreateSubinterface(ctx context.Context, arg CreateSubinterfaceParams) (Subinterface, error) {
	row := q.db.QueryRow(ctx, CreateSubinterface,
		arg.IfID,
		arg.Ifindex,
		arg.Descr,
		arg.Alias,
		arg.Oper,
		arg.Adm,
		arg.Speed,
		arg.TypeEnum,
		arg.Mac,
		arg.Notes,
	)
	var i Subinterface
	err := row.Scan(
		&i.SifID,
		&i.IfID,
		&i.Ifindex,
		&i.Descr,
		&i.Alias,
		&i.Oper,
		&i.Adm,
		&i.Speed,
		&i.TypeEnum,
		&i.Mac,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const DeleteSubinterface = `-- name: DeleteSubinterface :exec
DELETE FROM subinterfaces
WHERE sif_id = $1
`

func (q *Queries) DeleteSubinterface(ctx context.Context, sifID int64) error {
	_, err := q.db.Exec(ctx, DeleteSubinterface, sifID)
	return err
}

const GetSubinterface = `-- name: GetSubinterface :one
SELECT sif_id, if_id, ifindex, descr, alias, oper, adm, speed, type_enum, mac, notes, updated_on, created_on
FROM subinterfaces
WHERE sif_id = $1
`

func (q *Queries) GetSubinterface(ctx context.Context, sifID int64) (Subinterface, error) {
	row := q.db.QueryRow(ctx, GetSubinterface, sifID)
	var i Subinterface
	err := row.Scan(
		&i.SifID,
		&i.IfID,
		&i.Ifindex,
		&i.Descr,
		&i.Alias,
		&i.Oper,
		&i.Adm,
		&i.Speed,
		&i.TypeEnum,
		&i.Mac,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const GetSubinterfaceInterface = `-- name: GetSubinterfaceInterface :one
SELECT t2.if_id, t2.con_id, t2.parent, t2.otn_if_id, t2.dev_id, t2.ent_id, t2.ifindex, t2.descr, t2.alias, t2.oper, t2.adm, t2.speed, t2.minspeed, t2.type_enum, t2.mac, t2.monstatus, t2.monerrors, t2.monload, t2.updated_on, t2.created_on, t2.montraffic
FROM subinterfaces t1
  INNER JOIN interfaces t2 ON t2.if_id = t1.if_id
WHERE t1.sif_id = $1
`

// Foreign keys
func (q *Queries) GetSubinterfaceInterface(ctx context.Context, sifID int64) (Interface, error) {
	row := q.db.QueryRow(ctx, GetSubinterfaceInterface, sifID)
	var i Interface
	err := row.Scan(
		&i.IfID,
		&i.ConID,
		&i.Parent,
		&i.OtnIfID,
		&i.DevID,
		&i.EntID,
		&i.Ifindex,
		&i.Descr,
		&i.Alias,
		&i.Oper,
		&i.Adm,
		&i.Speed,
		&i.Minspeed,
		&i.TypeEnum,
		&i.Mac,
		&i.Monstatus,
		&i.Monerrors,
		&i.Monload,
		&i.UpdatedOn,
		&i.CreatedOn,
		&i.Montraffic,
	)
	return i, err
}

const GetSubinterfaces = `-- name: GetSubinterfaces :many
SELECT sif_id, if_id, ifindex, descr, alias, oper, adm, speed, type_enum, mac, notes, updated_on, created_on
FROM subinterfaces
WHERE (
    $1::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on >= $1
  )
  AND (
    $2::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR updated_on <= $2
  )
  AND (
    $3::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on >= $3
  )
  AND (
    $4::TIMESTAMPTZ = '0001-01-01 00:00:00+00'
    OR created_on <= $4
  )
  AND (
    $5::text IS NULL
    OR ($5::text = 'isnull' AND ifindex IS NULL)
    OR ($5::text = 'isempty' AND CAST(ifindex AS text) = '')
    OR CAST(ifindex AS text) LIKE $5
  )
  AND (
    $6::text = ''
    OR ($6 = 'isempty' AND descr = '')
    OR descr ILIKE $6
  )
  AND (
    $7::text IS NULL
    OR ($7::text = 'isnull' AND alias IS NULL)
    OR ($7::text = 'isempty' AND alias = '')
    OR alias ILIKE $7
  )
  AND (
    $8::text IS NULL
    OR ($8::text = 'isnull' AND oper IS NULL)
    OR ($8::text = 'isempty' AND CAST(oper AS text) = '')
    OR CAST(oper AS text) LIKE $8
  )
  AND (
    $9::text IS NULL
    OR ($9::text = 'isnull' AND adm IS NULL)
    OR ($9::text = 'isempty' AND CAST(adm AS text) = '')
    OR CAST(adm AS text) LIKE $9
  )
  AND (
    $10::text IS NULL
    OR ($10::text = 'isnull' AND speed IS NULL)
    OR ($10::text = 'isempty' AND CAST(speed AS text) = '')
    OR CAST(speed AS text) LIKE $10
  )
  AND (
    $11::text IS NULL
    OR ($11::text = 'isnull' AND type_enum IS NULL)
    OR ($11::text = 'isempty' AND CAST(type_enum AS text) = '')
    OR CAST(type_enum AS text) LIKE $11
  )
  AND (
    $12::macaddr IS NULL
    OR mac = $12
  )
  AND (
    $13::text IS NULL
    OR ($13::text = 'isnull' AND notes IS NULL)
    OR ($13::text = 'isempty' AND notes = '')
    OR notes ILIKE $13
  )
ORDER BY created_on
LIMIT NULLIF($15::int, 0) OFFSET NULLIF($14::int, 0)
`

type GetSubinterfacesParams struct {
	UpdatedGe time.Time      `json:"updated_ge"`
	UpdatedLe time.Time      `json:"updated_le"`
	CreatedGe time.Time      `json:"created_ge"`
	CreatedLe time.Time      `json:"created_le"`
	IfindexF  *string        `json:"ifindex_f"`
	DescrF    string         `json:"descr_f"`
	AliasF    *string        `json:"alias_f"`
	OperF     *string        `json:"oper_f"`
	AdmF      *string        `json:"adm_f"`
	SpeedF    *string        `json:"speed_f"`
	TypeEnumF *string        `json:"type_enum_f"`
	MacF      pgtype.Macaddr `json:"mac_f"`
	NotesF    *string        `json:"notes_f"`
	OffsetQ   int32          `json:"offset_q"`
	LimitQ    int32          `json:"limit_q"`
}

func (q *Queries) GetSubinterfaces(ctx context.Context, arg GetSubinterfacesParams) ([]Subinterface, error) {
	rows, err := q.db.Query(ctx, GetSubinterfaces,
		arg.UpdatedGe,
		arg.UpdatedLe,
		arg.CreatedGe,
		arg.CreatedLe,
		arg.IfindexF,
		arg.DescrF,
		arg.AliasF,
		arg.OperF,
		arg.AdmF,
		arg.SpeedF,
		arg.TypeEnumF,
		arg.MacF,
		arg.NotesF,
		arg.OffsetQ,
		arg.LimitQ,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subinterface
	for rows.Next() {
		var i Subinterface
		if err := rows.Scan(
			&i.SifID,
			&i.IfID,
			&i.Ifindex,
			&i.Descr,
			&i.Alias,
			&i.Oper,
			&i.Adm,
			&i.Speed,
			&i.TypeEnum,
			&i.Mac,
			&i.Notes,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSubinterface = `-- name: UpdateSubinterface :one
UPDATE subinterfaces
SET if_id = $2,
  ifindex = $3,
  descr = $4,
  alias = $5,
  oper = $6,
  adm = $7,
  speed = $8,
  type_enum = $9,
  mac = $10,
  notes = $11
WHERE sif_id = $1
RETURNING sif_id, if_id, ifindex, descr, alias, oper, adm, speed, type_enum, mac, notes, updated_on, created_on
`

type UpdateSubinterfaceParams struct {
	SifID    int64          `json:"sif_id"`
	IfID     *int64         `json:"if_id"`
	Ifindex  *int64         `json:"ifindex"`
	Descr    string         `json:"descr"`
	Alias    *string        `json:"alias"`
	Oper     *int16         `json:"oper"`
	Adm      *int16         `json:"adm"`
	Speed    *int64         `json:"speed"`
	TypeEnum *string        `json:"type_enum"`
	Mac      pgtype.Macaddr `json:"mac"`
	Notes    *string        `json:"notes"`
}

func (q *Queries) UpdateSubinterface(ctx context.Context, arg UpdateSubinterfaceParams) (Subinterface, error) {
	row := q.db.QueryRow(ctx, UpdateSubinterface,
		arg.SifID,
		arg.IfID,
		arg.Ifindex,
		arg.Descr,
		arg.Alias,
		arg.Oper,
		arg.Adm,
		arg.Speed,
		arg.TypeEnum,
		arg.Mac,
		arg.Notes,
	)
	var i Subinterface
	err := row.Scan(
		&i.SifID,
		&i.IfID,
		&i.Ifindex,
		&i.Descr,
		&i.Alias,
		&i.Oper,
		&i.Adm,
		&i.Speed,
		&i.TypeEnum,
		&i.Mac,
		&i.Notes,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}
